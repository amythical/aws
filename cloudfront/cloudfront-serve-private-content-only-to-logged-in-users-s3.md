# Usecase
Users can access public images using a path like public/image1.png and protected images like protected/image2.png using the same CDN/CloudFront distribution url. Protected images require the user to be logged into to the app to view them.

# Last Update 
Oct 22 - Adding this as AWS keeps updating, this date helps to know if the solution is outdated

# Approach
## Part 1 - Use CloudFront Paths
CloudFront has a path pattern feature where different origins(and hence S3 buckets) can be linked based on the path of the resource. We link public/image1.png to the public S3 bucket and protected/image2.png to another protected S3 bucket.

## Part 2 - Use signed cookies from CloudFront to give access to protected content
After the user logs into the app, create signed Cookies for CloudFront. These cookies will need to be signed using a Signer (public + private key pair). On CloudFront upload the public key and modify the protected resources path which need a check on the signed cookies. Requests without signed cookies should be denied access when they try and view the protected content.

# Note on signed urls
Signed urls are also available from S3 which could leverage the Authorization header and provide permissions as per IAM Roles, but If we use S3 signed urls the entire purpose of CDN caching does not come into play and every single request hits the S3 bucket. This is as good as not using the CDN.
CloudFront introduced signed urls and signed cookies to block/permit access to private/protected content. We will use signed cookies to ensure we leverage the CDN cache while accessing the images from the S3 bucket.

# Implementation Part 1 - Using CloudFront Paths
## Create another S3 Bucket
- Create a bucket in S3, called 'ptotected-assets' block all public access
- Create a folder called 'protected'
- Upload an image to the bucket say wallpaper.png to the folder called 'protected'
- From the buckets Objects Tab -> wallpaper.png, copy the Object url
- If you paste it in your browser you should get a 
```
<Error>
<Code>AccessDenied</Code>
<Message>Access Denied</Message>
<RequestId>SomeRand0mNumbers&Characters</RequestId>
<HostId>SomeMoreRand0mNumbers&Characters</HostId>
</Error>
```
- So we now have a S3 Bucket with private access such that no one can access it using the S3 Object urls

## CloudFront Add New Origin
- CloudFront -> Distributions -> Your distribution
- Continuing from [Linking S3 Bucket to CDN for public access](https://github.com/amythical/aws/blob/main/cloudfront/cloudfront-public-access-private-s3-bucket.md), we assume there is an origin called 'public-assets' linking the 'public-assets' S3 bucket to the CDN
- Go to the Origins Tab and click Create origin
   - Origin domain - Choose the bucket 'protected-assets' we just created above
    - Origin path can be empty
    - Name would be autopopulated with origins name or edit and add your own eg 'protected-assets-origin'
    - Origin access select Origin access control settings (recommended) Bucket can restrict access to only CloudFront.
    - Origin access control -> Create control setting
        - Name eg cdn-s3-protected-access
        - Description can be optional
        - Signing behaviour, select Sign requests (recommended) and check Do not override authorization header
    - Copy the auto generated policy 'Copy Policy' button and store it somewhere handy
    - Create

## Give the new S3 Bucket permissions to CloudFront Distribution
  - S3 Buckets -> protected-assets -> Permissions Tab
  - Bucket policy -> Edit
  - Paste the autogenerated policy for we stashed above
  - Save change (to policy)

## Configure CloudFront paths
- CloudFront -> Distributions -> Your Distribution -> Behaviours tab
- We will see a default behavior with path pattern as Default(*), this is mapped to our 'public-assets' origin
- Create the path for the public assets
    - Click on Create Behaviour in the Edit Behaviour form
    - Path pattern - /public/*
    - Origin and origin groups - select the 'public-assets' origin
    - Rest of the options can be default
    - Save Changes
- Create the path for the protected assets
    - Click on Create Behaviour in the Edit Behaviour form
    - Path pattern - /protected/*
    - Origin and origin groups - select the 'protected-assets' origin
    - Rest of the options can be default
    - Save Changes

## Add a folder to the 'public-assets' bucket
  - S3 Buckets, public-assets, create a folder called 'public'
    - Upload an image say image1.png to it
    - From the buckets Objects Tab -> image1.png, copy the Object url
    - If you paste it in your browser you should get 

    ```
    <Error>
    <Code>AccessDenied</Code>
    <Message>Access Denied</Message>
    <RequestId>SomeRand0mNumbers&Characters</RequestId>
    <HostId>SomeMoreRand0mNumbers&Characters</HostId>
    </Error>
    ```
    - So the public folder cannot be accessed using the S3 Object urls


## Check access to images using paths
### Check the /public assets
- CloudFront->Distributions->Your distribution->General, copy the distribution name (which looks like https://abcd.cloudfront.net)
- In your browser try https://abcd.cloudfront.net/public/image1.png
- Yay! we now see the image using CloudFront!
- Because the path contained /public our requested was routed and fetched from the public-assets bucket as per our configuration in CloudFront Behaviours (paths)

### Check the /protected assets
- CloudFront->Distributions->Your distribution->General, copy the distribution domain name (which looks like https://abcd.cloudfront.net)
- In your browser try https://abcd.cloudfront.net/protected/wallpaper.png
- You should see the image
- So the /protected path takes us to the protected-assets bucket
> This image is not really protected as of now, as anyone can access it.

# Implementation - Part 2 - give access to logged in users only for the protected-assets
## Create a public/private key pair
- Use your console/terminal/commandline (Im on a Mac so using terminal)
```

openssl genrsa -out private_key.pem 2048

# The resulting file contains both the public and the private key. The following example command extracts the public key from the file named private_key.pem

openssl rsa -pubout -in private_key.pem -out public_key.pem
```
[Source - AWS Docs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-trusted-signers.html#private-content-creating-cloudfront-key-pairs)
- Store these safely and keep them handy

## Upload the public key
- Go to CloudFront Home/Dashboard
- Left Menu -> Key Management -> Public Keys
- Click Create a Public Key
- Give it a name eg publickkey-cloudfront-sign-protected-assets and a description (optional)
- In your console/terminal change to the directory with the public_key.pem file we created in "Create a public/private key pair" and run this command
```
cat public_key.pem
```
should output something like
```
-----BEGIN PUBLIC KEY-----
ALotOfCharatersAndNumbersALotOfCharatersAndNumbersALotOfCharatersAndNumbersALotOfCharatersAndNumbersALotOfCharatersAndNumbersALotOfCharatersAndNumbers
-----END PUBLIC KEY-----
```
- As per the instructions 'Paste the public key value in PEM format, including -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY-----' in the Key text input
- Click on Create Public Key

# Create a Key Group in CloudFront
- CloudFront -> Dashboard/Home
- Left Menu -> Key Management -> Key Groups
- Create a new Key Group
- Give it a name eg 'keygroup-cloudfront-sign-protected-assets'
- Description is optional
- In the public keys select the 'publickkey-cloudfront-sign-protected-assets' key we uploaded in 'Upload the public key'
- Click Create Key Group
## Assign Key groups for authorization to the CloudFront Distribution
- CloudFront Dashboard -> Your Distribution
- Behaviours -> Path pattern '/protected/*', select and Edit
- Restrict viewer access
    - select Yes
    - Trusted authorization type, Trusted key groups (recommended)
    - Choose the key groups, select 'keygroup-cloudfront-sign-protected-assets' we create in 'Create a Key Group in CloudFront'
- Save Changes

## Check if the protected assets can be accessed publicly
- In your browser go to https://yourcloudfront-distributiondomain-name(looks like abcd.cloudfront.net)/protected/wallpaper.png 
- You should see an Error Message like 
```
<Error>
<Code>MissingKey</Code>
<Message>Missing Key-Pair-Id query parameter or cookie value</Message>
</Error>
```
- So our protected resource cannot be accessed without signed urls or signed cookies

## Completed CloudFront configuration
This covers the CloudFront configuration.
Any resource accessed with CloudFrontUrl/protected/resource.format will expect Cookies in the header which are signed by the keypair we generated in 'Create a public/private key pair'.

If we want only our logged in users to access the 'protected' assets, we need to sign cookies after the user logs in to the app using the public and private keys.

## Create Signed urls for CloudFront in the app
- We begin with signed urls, as if we are checking on a localhost the signed url will tell us if the signing is working fine. Signed cookies with require a CNAME configuration in CloudFront.

- Add this code at a point where the user has logged in
```
const AWS = require('aws-sdk');

// Try to use process.env.PRIVATE_KEY instead of exposing your key
  const privateKey = `-----BEGIN RSA PRIVATE KEY-----
ABCDSEFGHJI87654345678
ABCDSEFGHJI87654345678
ABCDSEFGHJI87654345678
-----END RSA PRIVATE KEY-----`;

/* 
PUBLIC ACCESS KEY is the Key of the public key we uploaded in Cloudfront 
CloudFront->KeyManagement->PublicKeys, value of the ID column
*/
const PUBLIC_ACCESS_KEY = 'ABCDEFGH';
const cloudFront = new AWS.CloudFront.Signer(PUBLIC_ACCESS_KEY, privateKey);

const policy = JSON.stringify({
    Statement: [
      {
        Resource:
          'https://abcdefgh.cloudfront.net/protected/wallpaper.png',
        Condition: {
          DateLessThan: {
            'AWS:EpochTime':
              Math.floor(new Date().getTime() / 1000) + 60 * 60 * 1, // Current Time in UTC + time in seconds, (60 * 60 * 1 = 1 hour)
          },
        },
      },
    ],
});

const tExpires = Math.floor(new Date().getTime() / 1000) + 0.25 * 60 * 60;
  try {
    let tUrl = cloudFront.getSignedUrl({
      url: 'https://abcdefgh.cloudfront.net/protected/wallpaper.png',
      expires: tExpires,
      // policy,// doesnt work
    });
    console.log(`CLOUDFRONT SIGNED URL ${tUrl}`);
    return tUrl;
  } catch (ex) {
    console.log(`CLOUDFRONt SIGNIGN ERROR ${ex}`);
    throw ex;
  }
```
- I took the initial code from [gosink.in](https://www.gosink.in/node-js-serve-private-content-using-aws-cloudfront/) but I had to make some changes as I encountered errors, the code is after i made the changes and it worked printing a valid Url
- Points to watch out for when using cloudFront getSignedUrl()
    - Using CloudFront signer from aws-sdk gives an error 'split of undefined' when a custom policy is used, so to bypass this error I used the url and expires options while creating the Signed Url
    - I saw numerous posts on 
    - I got a 'Error: error:0906D066:PEM routines:PEM_read_bio:bad end line' error, so VS code has added additional spacing around my private key code (Not a good idea to add the private key in the code but this was a first test, including it in the ENV variables/env file is a preferred option)
    - Also for PEM read errors check if the BEGIN and END Headers have 5 hyphens
    - The time format for expires took me some digging, its a UTC time format, which in javascript is Math.floor((new Date()).getTime() / 1000), I just added some time in seconds after it as expiry time

>IMPORTANT! - 'PUBLIC_ACCESS_KEY' refers to the id of the uploaded public key 
- Get the KeyPair Id by going to CloudFront->Key Management -> Public Keys, see the ID column of our public key named 'publickkey-cloudfront-sign-protected-assets'

## Testing the protected resource using the signed url
- We get a url printed on our console that looks like https://abcdefg.cloudfront.net/protected/myimage.png?Expires=12345678&Key-Pair-Id=ABCDEFGH&Signature=L0ts0fAplh4numer1cCharacter5
- If we paste this in our browser, YAY! we see the protected image
- So signed urls work

## What if we want to use a custom policy in CloudFront signed Urls?
- I checked various forums and the 'split of undefined' error when using a custom policy was reported, I saw a few PRs too
- My current aws-sdk version was 2.2.25, so I tried removing it and updating to the latest aws-sdk ver 3 is available but installing and migrating v2 code to v3 seemed a daunting task
> So putting this issue on hold and Ill be using the url and expires to create a Signed Url

## Using another library aws-cloudfront-sign
- Browsing through [helpex](https://helpex.vn/question/how-to-use-cloudfront-signed-cookies-in-the-browser-60e2d36232040a402755ca95) I found a npm library which seemed convenient to create and use CloudFront Cookies
- we could use the aws-sdk but we would have to create 3 cookies and remember them for referencing, this library appeared simpler
- The [aws-cloudfront-sign](https://github.com/jasonsims/aws-cloudfront-sign) library also supports only the url and creds not custom policy, but will live with that for now as long as cookies paths can take wildcard characters for resources 

```
npm install aws-cloudfront-sign

```
- The code for getting a signed url now changes to
```
const cloudFrontSigner = require('aws-cloudfront-sign');

 // Try to use process.env.PRIVATE_KEY instead of exposing your key
  const privateKey = `-----BEGIN RSA PRIVATE KEY-----
ABCDEFGH1234567890
ABCDEFGH1234567890
ABCDEFGH1234567890
-----END RSA PRIVATE KEY-----`;

const tExpires = Math.floor(new Date().getTime()) + 0.125 * 60 * 60 * 1000; // 15 mins - IMPORTANT Time converted to millis thats what ver 2 of aws-cloudfront-sign needs

let options = {
  keypairId: 'ABCDEF',
  privateKeyString: privateKey,
  expireTime: tExpires,
};

var signedUrl = cloudFrontSigner.getSignedUrl('https://abcdefg123.cloudfront.net/protected/wallpaper.png', options);

console.log('Signed URL: ' + signedUrl);
```
- Copy the url printed on our console that looks like https://abcdefg.cloudfront.net/protected/myimage.png?Expires=12345678&Key-Pair-Id=ABCDEFGH&Signature=L0ts0fAplh4numer1cCharacter5
- If we paste this in our browser, YAY! we see the protected image
- So signed urls work using the new library

## Subdomains to be created before using Signed Cookies 
- Because we have cookies, we will need them to be created by a subdomain of our domain
- Say our domain is example.com, and our webapp is hosted on app.example.com, so the webapp needs a subdomain
- The cloudfront distribution needs to be mapped to a subdomain of example.com eg cdn.example.com
- When cookies are created at the highest level they are passed between subdomains, so a request to cdn.example.com will receive cookies created by app.example.com for the domain example.com
- >Block CNAME Vs A record - Use CNAME to create a subdomain and point it to another domain or an A record to point it to an IP Address
- I have Route53 on AWS but you can use godaddy or any domain provider to configure a subdomain using a cname
- In Route53 I created a subdomain cdn.example.com as a CNAME and pointed it to the domain name given to us by the CloudFront Distribution (Found in CloudFront->Distributions->Distribution Domain Name) and it looks like abcd1234.cloudfront.net
- The app will also need a subdomain without which checking cookies is difficult
- My setup is the webapp is on app.example.com and cloudfront is on cdn.example.com

## CNAME/Alternate domain changes in CloudFront distribution
- Having created a subdomain we have to add the subdomain to CloudFront or the mapping gives an Access Denied Error
- CloudFront -> Distributions -> Settings -> Alternate domain name (CNAME) - optional
add cdn.example.com
- Custom SSL certificate - optional
Select/Upload a SSL certificate
- Save Changes
- Check this by requesting a public image on the new subdomain eg https://cdn.example.com/public/image1.png should get us the image we got when we tested the public path in "Check the /public assets" 

## CloudFront signed cookies using aws-cloudfront-sign
- If we recall 3 cookies need to be signed and set for CloudFlare [source](https://docs.amazonaws.cn/en_us/AmazonCloudFront/latest/DeveloperGuide/private-content-setting-signed-cookie-custom-policy.html)
- The code for signing cookies is much simpler using the aws-cloudfront-sign library
```
 // Try to use process.env.PRIVATE_KEY instead of exposing your key
  const privateKey = `-----BEGIN RSA PRIVATE KEY-----
ABCDEFGHIJ1234567890
ABCDEFGHIJ1234567890
ABCDEFGHIJ1234567890
-----END RSA PRIVATE KEY-----`;

 
const tExpires = Math.floor(new Date().getTime()) + 0.125 * 60 * 60 * 1000; // 15 mins - IMPORTANT Time converted to millis thats what ver 2 of aws-cloudfront-sign needs

let options = {
  keypairId: 'ABCDEF',
  privateKeyString: privateKey,
  expireTime: tExpires,
};
  const signedCookies = cloudFrontSigner.getSignedCookies(
    'https://cdn.example.com/protected/*', // IMPORTANT not to use cloudfront domain here now that we have a subdomain configured
    options,
  );

  // You can now set cookies in your response header. For example:
  for (let cookieId in signedCookies) {
    res.cookie(cookieId, signedCookies[cookieId], {
      domain: '.example.com', // Cookies set at highest domain level
    });
  }
```
- Note - We will set the cookies at the highest domain level here 

## Debugging 'Access Denied' Errors when using Signed Cookies
### Check the Signer Settings
 I got a Access Denied errors when I tested using Signed Cookie and debugged this for a long the time, the Signed Url worked fine though so there had to be issues with my cookie setup, here are the likely candidates for the 'Access Denied' issue 
  - Note the change in the path in the signedCookies parameters, they use the sub-domain we have created for the CDN or we will get an Access Denied error
  - IMPORTANT! -  Set an expires time, the default time set by the package is 30 seconds, if like me you make a build and deploy it to the server the time is easily a lot more than the default 30 seconds of expiry
  - Setting paths on https and http too are candidates for Access Denied Errors
  - Check the domain the cookies are set on if its a subdomain or an incorrect domain you will likely get the Access Denied issue
 
 ### Using curl for sending Cookies
 - We can use CURL from the terminal to check whats happening
```
curl -v  -H "origin: https://example.com" -H "cookie: CloudFront-Key-Pair-Id=ABCDEFG;CloudFront-Policy=abcd567890;CloudFront-Signature=abcd123456â€ https://cdn.example.com/protected/wallpaper.png
```
- This returns the headers and error/success codes

### Enabling Logging on CloudFront
- Enabling logging on the CloudFront Distribution mapping it to a S3 bucket did not help much, but this can help confirm if your cookies are travelling all the way up to CloudFront (CloudFront->Distrubutions->Your Distribution->Settings)
  - Standard settings on
    - Pick a S3 bucket, best to have a public bucket for testing and delete it later after debugging (for production scenes follow a proper permission via S3 policies)
    - I got some ACL errors on enabling the logging in CloudFront, to fix this go to S3->Your bucket->Permissions tab->Object ownership, select Edit and ACLs enabled
  - Cookie settings on


### Decode your Policy and check the parameters
 - Im on a mac, so on the terminal there are utilities to decode your base64 encoded policy, same should work on linux but do check the base64 option flags on your distro as they may change 
 ```
 echo -n yourbase64encodedpolicyfromthecookieCloudFrontPolicy | base64 -Dd

 Outputs something like
 {"Statement":[{"Resource":"https://cdn.cloudfront.net/protected/*","Condition":{"DateLessThan":{"AWS:EpochTime":1664595449}}}  
```
- _I found a mistake I overlooked in the code by looking at my decoded policy, the domain is incorrect in the url it should have been 'cdn.example.com' and not the 'cloudfront.net' in the url, so this decoding and checking certainly helped_

### Expires time in aws-cloudfront-sign
- Default expires time in aws-cloudfront-sign is 30 seconds, so if your late trying out the urls/cookies this will result in a 'Access Denied' error
- I totally missed this and struggled a lot on the time, the new version of aws-cloudfront-sign accepts the expire time in milliseconds
- _Tip - try your time settings with the signed urls before applying them to cookies, because we can immediately click on the link to check the result_

## How do we check CloudFront cookies on localhost?
- You will have to map a subdomain to your local host
  - If you have a static IP then the subdomain can be an A record and can point to your static IP Address
  - [ngrok](https://ngrok.com/) could also work, with a paid version it offers CNAME mapping options 
  - [x] I tried mapping a subdomain as a CNAME from Route53 to a free ngrok domain but that did not work

 ## Testing Cloudfront Cookies 
 ### Without app login
  - https://cdn.example.com/public/image1.png works in the browser - Good
  - https://cdn.example.com/protected/wallpaper.png is Forbidden - Good
  - So this is what we wanted when a user is not logged into the app

  ### After logging into the app 
   - https://cdn.example.com/protected/wallpaper.png works in the browser when used in the address bar

  ### What about <img/> tags?
  - So even though https://cdn.example.com/protected/wallpaper.png worked in the browser, ```<img src='https://cdn.example.com/protected/wallpaper.png'> ``` gave a 403
  - If you see the headers in Chrome dev tools, with the img tag the CloudFront headers are not passed
  - I then modifed the img tage to include crossOrigin attributute, trying this in Dev tools I could see the CloudFront headers being passed with the request
  ```
  <img src='https://cdn.example.com/protected/wallpaper.png' crossOrigin="use-credentials">

  ```
- Still no luck, I got a 200 on the status and a CORS error
- Go to CloudFront, Behaviours, select the /protected/* path and select Edit
  - Viewer, Allowed HTTP methods - GET, HEAD, OPTIONS
  - Cache HTTP methods, select OPTIONS
  - Origin request policy - optional - Select CORS-S3Origin
  - Save Changes
- S3, Buckets go to our protected bucket
  - Cross-origin resource sharing (CORS)


```
  [
    {
        "AllowedHeaders": [],
        "AllowedMethods": [
            "GET",
            "HEAD"
        ],
        "AllowedOrigins": [
            "https://*.example.com"
        ],
        "ExposeHeaders": [
            "ETag"
        ]
    }
]
```

- After logging in to the app I had a page with 

```
<img src='https://cdn.example.com/public/image.png'> <br/>
<img src='https://cdn.example.com/protected/wallpaper.png' crossOrigin="use-credentials">
```
- With use-credentials the img tag could now load the protected images, YAY!!! finally after a day and a half I could get this working ...


## Added Security on S3
- Only users logged into the app can view the image but a logged in user can also copy the image url and because they have the cookies, they can paste the image url in the browser and view it outside the app
- To prevent this such that the image can be only opened from inside your webapp, add the following to the S3 policy
- S3 -> Bucket -> Permissions -> Bucket Policy -> edit

```
{
    "Version": "2008-10-17",
    "Id": "PolicyForCloudFrontPrivateContent",
    "Statement": [
        {
            "Sid": "AllowCloudFrontServicePrincipal",
            "Effect": "Allow",
            "Principal": {
                "Service": "cloudfront.amazonaws.com"
            },
            "Action": "s3:GetObject",
            "Resource": "arn:aws:s3:::protected-s3-bucket-name/*",
            "Condition": {
                "StringEquals": {
                    "AWS:SourceArn": "arn:aws:cloudfront::1234567890 :distribution/ABCDEFGHIJ"
                },
                "StringLike": {
                    "aws:Referer": "https://example.com/*"
                }
            }
        }
    ]
}
```

- Save Policy 
- CloudFront -> Distributions -> My Distribution -> Behaviours -> protected-> Cache key and origin requests -> Select UserAgentRefererHeaders 
- We need to select UserAgentRefererHeaders so that our asset is only loaded when requested from our domain
- Disable and Enable the CloudFront Distribution (CloudFront -> Dashboard->Select distribution and Enable/Disable button)
- Accessing the image directly from the browser should now give an Access Denied message


## Cleaning up Cookies on Logout
 - The Signed Cookies are not deleted when a user logs out so we will need to add code to delete them on the logout function
 - Also if you have a 'remember-me' feature you will need to create the cookies on an auto-login if they expire in a short time

## Update for Audio content
I tried using an audio tag in ReactJs to fetch an audio file, but I got all sorts of errors ranging from 403 to 206. here is what worked for me, additional settings to CloudFront cache and response headers
* CloudFront -> Policies ->Cache -> Create cache policy
  * Give it a name eg protected-assets-cache-policy
  * Headers - None
  * Querystrings - All
  * Cookies - All
  * Gzip and Brotli enabled (by default)
  * Save changes
* CloudFront -> Policies -> Response Headers -> Create Response Header policy
    * Name eg Cors policy for example.com
    * Configure Cors ON
    * Access-Control-Allow-Origin -> Customize add *.example.com
    * Access-Control-Allow-Headers -> Customize -> Add Headers - type in the input box 'Access-Control-Allow-Methods' (without the quotes)
    * Access-Control-Allow-Methods -> Customize -> Select GET, HEAD, OPTIONS (Customise this if needed)
    * Access-Control-Expose-Headers None
    * Access-Control-Allow-Credentials CHECKED
    * Origin override CHECKED
    * Rest can be default settings
    * Save Changes
* CloudFront -> Distributions -> Behaviours -> protected ->
  * Cache key and origin requests -> Cache policy and origin request policy (recommended)
    * Cache policy -> Select protected-assets-cache-policy
    * Origin request policy - optional -> Select UserAgentRefererHeaders
    * Response headers policy - optional -> Select Cors policy for example.com
    * Save Changes
* Cloudfront -> Distributions -> Disable/Enable

The Audio tag needs to be like
```
<audio src="https://cdn.example.com/protected/audio/myaudio.mp3" id="myPlayer" crossOrigin="use-credentials"/>
```
Happy listening to your mp3 saved on S3 and served via Cloudfront!

## Update for CloudFront caching
I observed that Cloudfront wasn't caching my content 'x-cache: Miss from cloudfront in Response Headers'
The following changes helped, I had to undo the referer changes in S3 for this to work
- CloudFront -> Distributions -> My Distribution -> Behaviour -> protected
  - Origin request policy -optional -> CORS-S3Origin
  - Response headers policy -optional -> CORS-With-Preflight
- S3 -> myprotectedbucket -> Permissions 
```
{
    "Version": "2008-10-17",
    "Id": "PolicyForCloudFrontPrivateContent",
    "Statement": [
        {
            "Sid": "AllowCloudFrontServicePrincipal",
            "Effect": "Allow",
            "Principal": {
                "Service": "cloudfront.amazonaws.com"
            },
            "Action": "s3:GetObject",
            "Resource": "arn:aws:s3:::protected-s3-bucket-name/*",
            "Condition": {
                "StringEquals": {
                    "AWS:SourceArn": "arn:aws:cloudfront::1234567890 :distribution/ABCDEFGHIJ"
                }
            }
        }
    ]
}
```
- CloudFront -> Distributions -> My Distribution -> Disable/Enable
- Now accessing the asset twice should show the second request getting a 'x-cache Hit from Cloudfront' in the Response Header.
- I will have to figure the heards needed to enable this with the referer setting in S3